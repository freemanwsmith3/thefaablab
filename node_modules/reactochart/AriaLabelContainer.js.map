{"version":3,"sources":["src/AriaLabelContainer.js"],"names":["AriaLabelContainer","propTypes","datasetWithAccessor","PropTypes","arrayOf","shape","data","object","isRequired","accessor","CustomPropTypes","valueOrAccessor","ariaLabelGenerator","func","onKeyDown","height","number","width","xScale","props","domain","groupedData","forEach","index","d","xValue","key","toString","Array","length","zippedDatapoints","Object","values","sort","a","b","numFrames","sliceWidth","map","event"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { ascending } from 'd3-array';\nimport * as CustomPropTypes from './utils/CustomPropTypes';\nimport { getValue } from './utils/Data';\n\nAriaLabelContainer.propTypes = {\n  /**\n   * An array containing n objects in the following shape:\n   * [{\n   *    data: Array of your data points, normally used in rendering specific line or area charts\n   *    accessor: A function used to access the data point on the x axis from the `data` attribute\n   *              (datum) => number\n   * }]\n   */\n  datasetWithAccessor: PropTypes.arrayOf(\n    PropTypes.shape({\n      data: PropTypes.arrayOf(PropTypes.object).isRequired,\n      accessor: CustomPropTypes.valueOrAccessor.isRequired,\n    }),\n  ).isRequired,\n  /**\n   * A function that takes the xValue at the start of the frame, an array of datapoints at that xValue, and the index of the frame,\n   * and returns a string to render as an aria label\n   * for the specific frame in the Interface.\n   *\n   * (xValue, [datapoints], frameIndex) => string\n   */\n  ariaLabelGenerator: PropTypes.func.isRequired,\n  /**\n   * an optional `onKeyDown` event handler to provide for each frame\n   * when selected.\n   * Best practices are to describe how the user will interact with the chart in\n   * the ariaLabelGenerator\n   *\n   * (event, xValue, [datapoints]) => void\n   */\n  onKeyDown: PropTypes.func,\n  /**\n   * height of the chart - provided by `XYPlot`\n   */\n  height: PropTypes.number,\n  /**\n   * width of the chart - provided by `XYPlot`\n   */\n  width: PropTypes.number,\n  /**\n   * D3 scale for X axis - provided by XYPlot\n   */\n  xScale: PropTypes.func,\n};\n\n/**\n * `AriaLabelContainer` provides a mechanism for keyboard navigation of\n * `LineChart` and `AreaChart` graphs within `XYPlot`. This component renders\n * a rectangle for a given `numFrames` across a Line/Area chart. `numFrames` should\n * be equal to the number of data points in your dataset. Users can navigate to a frame\n * either by pressing `Tab`, or through their assistive technology. `AriaLabelContainer`\n * takes an `ariaLabelGenerator`, which generates an aria-label for each frame of the chart.\n * [aria-labels](https://www.w3.org/TR/WCAG20-TECHS/ARIA6.html#ARIA6-description) are critical for users accessing\n * the web with screenreaders or other assistive technologies.\n */\n\nexport default function AriaLabelContainer(props) {\n  const {\n    ariaLabelGenerator,\n    onKeyDown,\n    height,\n    width,\n    datasetWithAccessor,\n    xScale,\n  } = props;\n\n  const domain = xScale.domain();\n\n  const groupedData = {};\n  // determine number of frames from n datasets with potentially different accessors\n  datasetWithAccessor.forEach(({ data, accessor }, index) => {\n    data.forEach(d => {\n      const xValue = getValue(accessor, d);\n      const key = xValue.toString();\n      if (!groupedData[key]) {\n        groupedData[key] = {\n          xValue,\n          data: new Array(datasetWithAccessor.length),\n          // account for missing datapoints in different datasets\n        };\n      }\n      groupedData[key].data[index] = d;\n    });\n  });\n\n  const zippedDatapoints = Object.values(groupedData).sort((a, b) =>\n    ascending(a.xValue, b.xValue),\n  );\n\n  const numFrames = zippedDatapoints.length;\n  const sliceWidth = width / (numFrames - 1);\n\n  return (\n    <g className=\"rct-chart-a11y\">\n      {zippedDatapoints.map(({ xValue, data }, index) => (\n        <rect\n          className=\"rct-chart-visually-hidden-rect\"\n          aria-label={ariaLabelGenerator(xValue, data, index)}\n          key={index}\n          height={height}\n          width={sliceWidth}\n          x={\n            xValue === domain[1]\n              ? xScale(zippedDatapoints[index - 1].xValue)\n              : xScale(xValue)\n            // otherwise the last rect renders outside the chart\n          }\n          y={0}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={event => {\n            if (!!onKeyDown) {\n              onKeyDown(event, xValue, data);\n            }\n          }}\n        />\n      ))}\n    </g>\n  );\n}\n"],"file":"AriaLabelContainer.js"}