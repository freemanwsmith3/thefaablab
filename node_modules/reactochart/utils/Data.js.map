{"version":3,"sources":["../src/utils/Data.js"],"names":["makeAccessor","key","identity","makeAccessor2","valueOrAccessor","getValue","accessor","args","datasetsFromPropsOrDescendants","props","Array","isArray","datasets","data","React","Children","count","children","forEach","child","concat","inferDataType","Error","every","d","i","undefined","inferDatasetsType","types","map","uniqTypes","length","isValidDomain","domain","type","isNumber","isDate","combineDomains","domains","dataType","combineBorderObjects","borderObjects","k","domainFromData","typeToUse","getDataDomainByAxis","horizontal","getX","getY","rangeAxis","domainFromDatasets","domainFromRangeData","rangeStartAccessor","rangeEndAccessor","dataTypeToUse","combineDatasets","datasetsInfo","combineKey","datasetLookups","datasetInfo","allCombineValues","uniqueValues","value","Date","toString","combineValue","combinedDatum","datasetIndex","dataKeys","Object","keys","datasetLookup","datum","newDataKey","originalDataKey"],"mappings":"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","sourcesContent":["import isFunction from 'lodash/isFunction';\nimport isNull from 'lodash/isNull';\nimport isUndefined from 'lodash/isUndefined';\nimport property from 'lodash/property';\nimport isNumber from 'lodash/isNumber';\nimport isDate from 'lodash/isDate';\nimport uniq from 'lodash/uniq';\nimport flatten from 'lodash/flatten';\nimport compact from 'lodash/compact';\nimport fromPairs from 'lodash/fromPairs';\nimport get from 'lodash/get';\nimport maxBy from 'lodash/maxBy';\nimport keyBy from 'lodash/keyBy';\nimport uniqBy from 'lodash/uniqBy';\nimport has from 'lodash/has';\nimport forEach from 'lodash/forEach';\nimport identity from 'lodash/identity';\nimport { extent } from 'd3-array';\nimport React from 'react';\n\n/**\n * `makeAccessor` creates an accessor or \"getter\" function given a variety of options\n * to be used for retrieving a data value from within an object or array\n *\n * If given a function, it is passed through.\n * If given null or undefined, the getter is the identity function - ie. returns whatever it's passed\n * If given an array index or deep object key string, the value will be retrieved using _.property\n *\n * @example\n * makeAccessor(null)(4); // 4\n * makeAccessor(d => d + 1)(4); // 5\n * makeAccessor(1)(['a', 'b', 'c']); // 'b'\n * makeAccessor('x.0.y')({x: [{y: 9}]}); // 9\n *\n * @param {any} key - Getter, which may be a function, integer, string, null, or undefined;\n * @returns {function} accessor - Accessor function\n */\nexport function makeAccessor(key) {\n  return isFunction(key)\n    ? key\n    : isNull(key) || isUndefined(key)\n    ? identity\n    : property(key);\n}\n\n/**\n * `makeAccessor2` creates a constant accessor function if passed a value,\n * if passed a function, just returns it\n */\nexport function makeAccessor2(valueOrAccessor) {\n  if (isFunction(valueOrAccessor)) return valueOrAccessor;\n  return () => valueOrAccessor;\n}\n\n/**\n * `getValue` takes as its first argument a value or an accessor function.\n * If it's a value (ie not a function), it is returned.\n * If a function, returns the result of calling function with remaining arguments\n */\nexport function getValue(accessor, ...args) {\n  return isFunction(accessor) ? accessor(...args) : accessor;\n}\n\n/**\n * `datasetsFromPropsOrDescendants` expects a `props` object which may have `children`.\n * if `props` has `data` or `datasets`, returns it; otherwise recursively searches props.children\n * for components have `data` or `datasets` and combines them into one `datasets` array.\n * `props.data` is wrapped in array because this returns `datasets` (multiple arrays of `data`)\n *\n * @param {Object} props - A React props object, which may have `children` with their own props.\n * @returns {Array.<Array>} datasets - An array of arrays of data objects\n */\nexport function datasetsFromPropsOrDescendants(props) {\n  if (Array.isArray(props.datasets)) {\n    return props.datasets;\n  } else if (Array.isArray(props.data)) {\n    return [props.data];\n  } else if (React.Children.count(props.children)) {\n    let datasets = [];\n    // use Children.forEach instead of map, because Children.map flattens the arrays\n    React.Children.forEach(props.children, child => {\n      datasets = datasets.concat(datasetsFromPropsOrDescendants(child.props));\n    });\n    return datasets;\n  }\n  return [];\n}\n\nexport function inferDataType(data, accessor = identity) {\n  if (!Array.isArray(data))\n    throw new Error('inferDataType expects a data array');\n  else if (data.every((d, i) => accessor(d, i) === undefined))\n    return 'categorical';\n  // should this be allowed?\n  else if (\n    data.every(\n      (d, i) => isNumber(accessor(d, i)) || accessor(d, i) === undefined,\n    )\n  )\n    return 'number';\n  else if (\n    data.every((d, i) => isDate(accessor(d, i)) || accessor(d, i) === undefined)\n  )\n    return 'time';\n  else return 'categorical';\n}\n\nexport function inferDatasetsType(datasets, accessor = identity) {\n  if (!Array.isArray(datasets))\n    throw new Error('inferDatasetsType expects a datasets array');\n\n  const types = datasets.map(data => inferDataType(data, accessor));\n  const uniqTypes = uniq(types);\n  return uniqTypes.length === 1 ? uniqTypes[0] : 'categorical';\n}\n\nexport function isValidDomain(domain, type = 'categorical') {\n  return (\n    Array.isArray(domain) &&\n    !!domain.length &&\n    // categorical domain can be any array of anything\n    (type === 'categorical' ||\n      // number/time domains should look like [min, max]\n      (type === 'number' && domain.length === 2 && domain.every(isNumber)) ||\n      (type === 'time' && domain.length === 2 && domain.every(isDate)))\n  );\n}\n\nexport function combineDomains(domains, dataType) {\n  if (!Array.isArray(domains)) return undefined;\n  return dataType === 'categorical'\n    ? uniq(flatten(compact(domains)))\n    : extent(flatten(domains));\n}\n\nexport function combineBorderObjects(borderObjects) {\n  return fromPairs(\n    ['top', 'bottom', 'left', 'right'].map(k => {\n      // combine border objects by taking the max value of each spacing direction\n      return [k, get(maxBy(borderObjects, k), k)];\n    }),\n  );\n}\n\nexport function domainFromData(data, accessor = identity, type = undefined) {\n  let typeToUse = type;\n\n  if (!typeToUse) typeToUse = inferDataType(data, accessor);\n\n  return typeToUse === 'number' || typeToUse === 'time'\n    ? extent(data.map(accessor))\n    : uniq(data.map(accessor));\n}\n\nexport function getDataDomainByAxis(props) {\n  const { horizontal, data, getX, getY } = props;\n  const accessor = horizontal ? makeAccessor(getY) : makeAccessor(getX);\n  const rangeAxis = horizontal ? 'y' : 'x';\n  return {\n    [rangeAxis]: domainFromData(data, accessor),\n  };\n}\n\nexport function domainFromDatasets(\n  datasets,\n  accessor = identity,\n  type = undefined,\n) {\n  // returns the default domain of a collection of datasets with an accessor function\n  // for numeric and date-type datasets, returns the extent (min and max) of the numbers/dates\n  // for categorical datasets, returns the set of distinct category values\n  let typeToUse = type;\n  if (!typeToUse) typeToUse = inferDatasetsType(datasets, accessor);\n  const domains = datasets.map(data =>\n    domainFromData(data, accessor, typeToUse),\n  );\n  return combineDomains(domains, typeToUse);\n}\n\nexport function domainFromRangeData(\n  data,\n  rangeStartAccessor,\n  rangeEndAccessor,\n  dataType,\n) {\n  // returns the domain of dataset for which each datum represents a range of values\n  // ie. has a start and end value rather than a single value\n  // for example, time ranges\n  let dataTypeToUse = dataType;\n  if (!dataTypeToUse) dataTypeToUse = inferDataType(data, rangeStartAccessor);\n\n  switch (dataTypeToUse) {\n    case 'number':\n    case 'time':\n      return extent(\n        flatten([\n          extent(data, (d, i) => +rangeStartAccessor(d, i)),\n          extent(data, (d, i) => +rangeEndAccessor(d, i)),\n        ]),\n      );\n    case 'categorical':\n      return uniq(\n        flatten([data.map(rangeStartAccessor), data.map(rangeEndAccessor)]),\n      );\n    default:\n      return [];\n  }\n}\n\nexport function combineDatasets(datasetsInfo = [], combineKey = 'x') {\n  // combineDatasets combines multiple datasets into one, joined on a common key 'combineKey'\n  // datasetsInfo is an array that looks like:\n  // [\n  //   {data: [{x: 0, y: 3}, ...], combineKey: 'x', dataKeys: {y: 'y0'}}\n  //   {data: [{count: 0, value: 4}], combineKey: 'count', dataKeys: {value: 'y1'}}\n  // ]\n  // where `data` is an array of data points of any shape\n  // `combineKey` is the key for the value which the datasets are joined on\n  // `dataKeys` are getters for other values in each datapoint which should be merged into the combined dataset\n  //   - key = getter in original datapoint, value = setter for combined dataset\n  // example above (with default combinedKey) results in:\n  // [{x: 0, y0: 3, y1: 4}, ...]\n\n  // index each dataset by its combineKey values so we can quickly lookup if it has data for a given value\n  const datasetLookups = datasetsInfo.map(datasetInfo => {\n    const { data } = datasetInfo;\n    return keyBy(data, datasetInfo.combineKey || combineKey);\n  });\n\n  // Grab combineKey from each dataset and flatten into one array\n  const allCombineValues = [].concat(\n    ...datasetsInfo.map(datasetInfo =>\n      datasetInfo.data.map(makeAccessor(datasetInfo.combineKey || combineKey)),\n    ),\n  );\n\n  // Get all unique values\n  const uniqueValues = uniqBy(allCombineValues, value => {\n    return value instanceof Date ? value.toString() : value;\n  });\n\n  // For each of the unique combineKey data values, go through each dataset and look for a combineKey value that matches\n  // if we find it, combine the values for that datum's dataKeys into the final combinedDatum object\n  return uniqueValues.map(combineValue => {\n    const combinedDatum = { [combineKey]: combineValue };\n\n    datasetsInfo.forEach((datasetInfo, datasetIndex) => {\n      if (!datasetInfo.dataKeys || !Object.keys(datasetInfo.dataKeys).length)\n        return;\n      const datasetLookup = datasetLookups[datasetIndex];\n      if (!has(datasetLookup, combineValue)) return;\n\n      const datum = datasetLookup[combineValue];\n      forEach(datasetInfo.dataKeys, (newDataKey, originalDataKey) => {\n        combinedDatum[newDataKey] = datum[originalDataKey];\n      });\n    });\n\n    return combinedDatum;\n  });\n}\n"],"file":"Data.js"}