{"version":3,"sources":["src/YAxisLabels.js"],"names":["resolveYLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","format","testLabels","map","value","i","MeasuredValueLabel","getLabel","labelStyle","defaultStyle","areLabelsDistinct","push","collisionCount","YAxisLabels","React","Component","getTickDomain","props","yScale","propsWithDefaults","defaultProps","yTickDomain","getMargin","position","placement","distance","getLabels","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginX","label","Math","ceil","width","tickCount","ticks","scaleType","propsFormats","formatStrs","Array","isArray","length","shouldComponentUpdate","nextProps","render","labelClassName","spacingLeft","spacingRight","offset","className","textAnchor","transform","y","x","onMouseEnter","onMouseMove","onMouseLeave","onClick","eventName","callback","dy","text","PropTypes","func","height","number","oneOf","nice","bool","array","oneOfType","object","string","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","onMouseClickLabel","fontFamily","fontSize","lineHeight","YAxisLabelDebugRect","xAdj","fill"],"mappings":"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","sourcesContent":["import defaults from 'lodash/defaults';\nimport isUndefined from 'lodash/isUndefined';\nimport last from 'lodash/last';\nimport max from 'lodash/max';\nimport capitalize from 'lodash/capitalize';\nimport get from 'lodash/get';\nimport isFunction from 'lodash/isFunction';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport MeasuredValueLabel from './MeasuredValueLabel';\nimport {\n  checkLabelsDistinct,\n  getLabelsYOverhang,\n  makeLabelFormatters,\n  getDefaultFormats,\n} from './utils/Label';\nimport { getValue } from './utils/Data';\nimport { getScaleTicks, getTickDomain, inferScaleType } from './utils/Scale';\nimport { bindTrailingArgs } from './util.js';\nimport xyPropsEqual from './utils/xyPropsEqual';\n\nfunction resolveYLabelsForValues(\n  scale,\n  values,\n  formats = [],\n  style,\n  force = true,\n) {\n  // given a set of Y-values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels which are distinct\n  // since we currently do not support rotated axis value labels,\n  // we do not check if they fit on the axis (unlike X labels), since all Y labels will have the same height\n  // returns the formatter and the generated labels\n\n  let labels;\n  const attempts = [];\n  const goodFormat = formats.find(format => {\n    const testLabels = values.map((value, i) =>\n      MeasuredValueLabel.getLabel({\n        value,\n        format,\n        style: defaults(\n          getValue(style.labelStyle, { value }, i),\n          style.defaultStyle,\n        ),\n      }),\n    );\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if (!areLabelsDistinct) {\n      attempts.push({ labels: testLabels, format, areLabelsDistinct });\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if (!isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {\n      labels,\n      format: goodFormat,\n      areLabelsDistinct: true,\n      collisionCount: 0,\n    };\n  }\n  // none of the sets of labels are good\n  // if we're not forced to decide, return all the labels we tried (let someone else decide)\n  if (!force) return { attempts };\n\n  // forced to decide, choose the least bad option\n  // super bad, we don't have any label sets with distinct labels. return the last attempt.\n  return last(attempts);\n}\n\nclass YAxisLabels extends React.Component {\n  static propTypes = {\n    /**\n     * D3 scale for Y axis - provided by XYPlot.\n     */\n    yScale: PropTypes.func,\n    /**\n     * Height of chart - provided by XYPlot.\n     */\n    height: PropTypes.number,\n    /**\n     * Width of chart - provided by XYPlot.\n     */\n    width: PropTypes.number,\n    /**\n     * Position of y axis labels. Accepted options are \"left\" or \"right\".\n     */\n    position: PropTypes.oneOf(['left', 'right']),\n    /**\n     * Placement of labels in regards to the y axis. Accepted options are \"before\" or \"after\".\n     */\n    placement: PropTypes.oneOf(['before', 'after']),\n    /**\n     * Label distance from Y Axis.\n     */\n    distance: PropTypes.number,\n    /**\n     * Round ticks to capture extent of given y domain from XYPlot.\n     */\n    nice: PropTypes.bool,\n    /**\n     * Number of ticks on axis.\n     */\n    tickCount: PropTypes.number,\n    /**\n     * Custom ticks to display.\n     */\n    ticks: PropTypes.array,\n    /**\n     * Inline style object applied to each label,\n     * or accessor function which returns a style object\n     *\n     * Disclaimer: labelStyle will merge its defaults with the given labelStyle prop\n     * in order to ensure that our collision library measureText is able to calculate the\n     * smallest amount of possible collisions along the axis. It's therefore dependent on\n     * fontFamily, size and fontStyle to always be passed in. If you're looking to have a centralized\n     * stylesheet, we suggest creating a styled label component that wraps YAxisLabels with your preferred styles.\n     */\n    labelStyle: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n    labelClassName: PropTypes.string,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingLeft\n     */\n    spacingLeft: PropTypes.number,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingRight\n     */\n    spacingRight: PropTypes.number,\n    /**\n     * `mouseenter` event handler callback, called when user's mouse enters the label.\n     */\n    onMouseEnterLabel: PropTypes.func,\n    /**\n     * `mousemove` event handler callback, called when user's mouse moves within the label.\n     */\n    onMouseMoveLabel: PropTypes.func,\n    /**\n     * `mouseleave` event handler callback, called when user's mouse leaves the label.\n     */\n    onMouseLeaveLabel: PropTypes.func,\n    /**\n     * `mouseclick` event handler callback, called when user's mouse clicks the label.\n     */\n    onMouseClickLabel: PropTypes.func,\n    /**\n     * An accessor function that returns the updated label.\n     *\n     * For example, given labels with real numbers one can pass in the following accessor,\n     * (label) => `${label}%`, to display percentages.\n     */\n    format: PropTypes.func,\n    /**\n     * Formats to use for the labels in priority order. XAxisLabels will try to be smart about which format\n     * to use that keeps the labels distinct and provides the least amount of collisions when rendered. Formats\n     * can be either string(s) or function(s), utilizing d3-format.\n     *\n     * For example, given labels with real numbers one can pass in [\".0%\"] for a rounded percentage, like 12%.\n     */\n    formats: PropTypes.array,\n    /**\n     * Custom labels provided. Note that each object in the array has to be of shape.\n     * `{\n     *  value,\n     *  text,\n     *  height,\n     *  width\n     * }`\n     * value - value you'd like this label to be aligned with\n     * text - text you'd like displayed\n     * height - height of the given label\n     * width - width of the given label\n     */\n    labels: PropTypes.array,\n    /**\n     * Adds vertical offset (along the YAxis) to the labels.\n     */\n    offset: PropTypes.number,\n  };\n\n  static defaultProps = {\n    offset: 0,\n    height: 250,\n    width: 400,\n    position: 'left',\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: '',\n    labelStyle: {\n      fontFamily: 'Helvetica, sans-serif',\n      fontSize: '14px',\n      lineHeight: 1,\n      textAnchor: 'end',\n    },\n  };\n\n  static getTickDomain(props) {\n    if (!props.yScale) return;\n    const propsWithDefaults = defaults({}, props, YAxisLabels.defaultProps);\n    return {\n      yTickDomain: getTickDomain(propsWithDefaults.yScale, propsWithDefaults),\n    };\n  }\n\n  static getMargin(props) {\n    const propsWithDefaults = defaults({}, props, YAxisLabels.defaultProps);\n    const { yScale, position, placement, distance } = propsWithDefaults;\n    const labels =\n      propsWithDefaults.labels || YAxisLabels.getLabels(propsWithDefaults);\n    const zeroMargin = {\n      marginTop: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0,\n    };\n\n    if (\n      (position === 'left' && placement === 'after') ||\n      (position === 'right' && placement === 'before')\n    )\n      return zeroMargin;\n\n    const marginX = max(labels.map(label => Math.ceil(distance + label.width)));\n    const [marginTop, marginBottom] = getLabelsYOverhang(\n      yScale,\n      labels,\n      'middle',\n    );\n\n    return defaults(\n      { [`margin${capitalize(position)}`]: marginX, marginTop, marginBottom },\n      zeroMargin,\n    );\n  }\n\n  static getLabels(props) {\n    const { tickCount, labelStyle, yScale } = defaults(\n      props,\n      {},\n      YAxisLabels.defaultProps,\n    );\n    const ticks = props.ticks || getScaleTicks(yScale, null, tickCount);\n    const style = {\n      labelStyle,\n      defaultStyle: YAxisLabels.defaultProps.labelStyle,\n    };\n    const scaleType = inferScaleType(yScale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs =\n      Array.isArray(propsFormats) && propsFormats.length\n        ? propsFormats\n        : getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const { labels } = resolveYLabelsForValues(yScale, ticks, formats, style);\n    // console.log('resolveYLabelsForValues took ', performance.now() - start);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  render() {\n    // todo: position: 'zero' prop to position along the zero line\n    const {\n      width,\n      yScale,\n      position,\n      distance,\n      labelStyle,\n      labelClassName,\n      spacingLeft,\n      spacingRight,\n      offset,\n    } = this.props;\n    const placement =\n      this.props.placement || (position === 'left' ? 'before' : 'after');\n    const className = `rct-chart-value-label rct-chart-value-label-y ${labelClassName}`;\n    const textAnchor = placement === 'before' ? 'end' : 'start';\n    const labels = this.props.labels || YAxisLabels.getLabels(this.props);\n    const transform =\n      position === 'left'\n        ? `translate(${-spacingLeft}, 0)`\n        : `translate(${width + spacingRight}, 0)`;\n\n    return (\n      <g\n        className=\"rct-chart-value-labels-y\"\n        transform={transform}\n        aria-hidden=\"true\"\n      >\n        {labels.map((label, i) => {\n          const y = yScale(label.value) + offset;\n          const x = placement === 'before' ? -distance : distance;\n\n          const [onMouseEnter, onMouseMove, onMouseLeave, onClick] = [\n            'onMouseEnterLabel',\n            'onMouseMoveLabel',\n            'onMouseLeaveLabel',\n            'onMouseClickLabel',\n          ].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = get(this.props, eventName);\n            return isFunction(callback)\n              ? bindTrailingArgs(callback, label.value)\n              : null;\n          });\n\n          const style = defaults(\n            { textAnchor },\n            getValue(labelStyle, { x, y, ...label }, i),\n            YAxisLabels.defaultProps.labelStyle,\n          );\n\n          return (\n            <g\n              key={`x-axis-label-${i}`}\n              {...{ onMouseEnter, onMouseMove, onMouseLeave, onClick }}\n            >\n              {/* <YAxisLabelDebugRect {...{x, y, label, style: getValue(labelStyle, label.text, i)}}/> */}\n              <MeasuredValueLabel\n                value={label.value}\n                {...{\n                  x,\n                  y,\n                  className,\n                  dy: '0.35em',\n                  style,\n                }}\n              >\n                {label.text}\n              </MeasuredValueLabel>\n            </g>\n          );\n        })}\n      </g>\n    );\n  }\n}\n\n/* eslint-disable */\nconst YAxisLabelDebugRect = () => {\n  const { x, y, label, style } = this.props;\n  const xAdj = style.textAnchor === 'end' ? x - label.width : x;\n  return (\n    <rect\n      {...{\n        x: xAdj,\n        y: y - label.height / 2,\n        width: label.width,\n        height: label.height,\n        fill: 'orange',\n      }}\n    />\n  );\n};\n/* eslint-enable */\n\nexport default YAxisLabels;\n"],"file":"YAxisLabels.js"}