{"version":3,"sources":["src/XAxisLabels.js"],"names":["resolveXLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","format","testLabels","map","value","i","MeasuredValueLabel","getLabel","labelStyle","defaultStyle","areLabelsDistinct","push","labelXRanges","label","textAnchor","collisionCount","distinctAttempts","filter","attempt","length","XAxisLabels","React","Component","getTickDomain","props","xScale","propsWithDefaults","defaultProps","xTickDomain","getMargin","position","placement","distance","getLabels","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginY","Math","ceil","height","noLabelOverhang","tickCount","ticks","propsFormats","scaleType","formatStrs","Array","isArray","shouldComponentUpdate","nextProps","render","labelClassName","spacingTop","spacingBottom","offset","className","transform","x","y","onMouseEnter","onMouseMove","onMouseLeave","onClick","eventName","callback","range","dy","text","PropTypes","number","oneOf","func","array","oneOfType","object","string","bool","nice","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","onMouseClickLabel","fontFamily","fontSize","lineHeight","XAxisLabelDebugRect","width","fill"],"mappings":"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","sourcesContent":["import defaults from 'lodash/defaults';\nimport isUndefined from 'lodash/isUndefined';\nimport last from 'lodash/last';\nimport minBy from 'lodash/minBy';\nimport max from 'lodash/max';\nimport capitalize from 'lodash/capitalize';\nimport get from 'lodash/get';\nimport isFunction from 'lodash/isFunction';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport MeasuredValueLabel from './MeasuredValueLabel';\nimport {\n  checkLabelsDistinct,\n  countRangeOverlaps,\n  getLabelsXOverhang,\n  getLabelXRange,\n  makeLabelFormatters,\n  getDefaultFormats,\n} from './utils/Label';\nimport { getValue } from './utils/Data';\nimport { getScaleTicks, getTickDomain, inferScaleType } from './utils/Scale';\nimport { bindTrailingArgs } from './util.js';\nimport xyPropsEqual from './utils/xyPropsEqual';\n\nfunction resolveXLabelsForValues(\n  scale,\n  values,\n  formats = [],\n  style,\n  force = true,\n) {\n  // given a set of values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels\n  // which are A) distinct and B) fit on the axis without colliding with each other\n  // returns the formatter and the generated labels\n\n  let labels;\n  const attempts = [];\n\n  const goodFormat = formats.find(format => {\n    const testLabels = values.map((value, i) => {\n      return MeasuredValueLabel.getLabel({\n        value,\n        format,\n        style: defaults(\n          getValue(style.labelStyle, { value }, i),\n          style.defaultStyle,\n        ),\n      });\n    });\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if (!areLabelsDistinct) {\n      attempts.push({ labels: testLabels, format, areLabelsDistinct });\n      return false;\n    }\n\n    const labelXRanges = testLabels.map(label =>\n      getLabelXRange(scale, label, style.textAnchor || 'middle'),\n    );\n    const collisionCount = countRangeOverlaps(labelXRanges);\n    if (collisionCount) {\n      // console.log(`labels do not fit on X axis, ${collisionCount} collisions`, _.map(testLabels, 'text'));\n      attempts.push({\n        labels: testLabels,\n        format,\n        areLabelsDistinct,\n        collisionCount,\n      });\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if (!isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {\n      labels,\n      format: goodFormat,\n      areLabelsDistinct: true,\n      collisionCount: 0,\n    };\n  }\n  // none of the sets of labels are good\n  if (!force)\n    // if we're not forced to decide, return all the labels we tried (let someone else decide)\n    return { attempts };\n\n  // forced to decide, choose the least bad option\n  // todo warn that we couldn't find good labels\n  const distinctAttempts = attempts.filter(\n    attempt => attempt.areLabelsDistinct,\n  );\n  return distinctAttempts.length === 0\n    ? last(attempts)\n    : minBy(distinctAttempts, 'collisionCount');\n}\n\nclass XAxisLabels extends React.Component {\n  static propTypes = {\n    height: PropTypes.number,\n    /**\n     * Position of x axis labels. Accepted options are \"top\" or \"bottom\".\n     */\n    position: PropTypes.oneOf(['top', 'bottom']),\n    /**\n     * Placement of labels in regards to the x axis. Accepted options are \"above\" or \"below\".\n     */\n    placement: PropTypes.oneOf(['below', 'above']),\n    /**\n     * D3 scale for X axis - provided by XYPlot.\n     */\n    xScale: PropTypes.func,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingTop.\n     */\n    spacingTop: PropTypes.number,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingBottom.\n     */\n    spacingBottom: PropTypes.number,\n    /**\n     * Label distance from X Axis.\n     */\n    distance: PropTypes.number,\n    /**\n     * Number of ticks on axis.\n     */\n    tickCount: PropTypes.number,\n    /**\n     * Custom ticks to display.\n     */\n    ticks: PropTypes.array,\n    /**\n     * Inline style object applied to each label,\n     * or accessor function which returns a style object\n     *\n     * Disclaimer: labelStyle will merge its defaults with the given labelStyle prop\n     * in order to ensure that our collision library measureText is able to calculate the\n     * smallest amount of possible collissions along the axis. It's therefore dependent on\n     * fontFamily, size and fontStyle to always be passed in. If you're looking to have a centralized\n     * stylesheet, we suggest creating a styled label component that wraps XAxisLabels with your preferred styles.\n     */\n    labelStyle: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n    labelClassName: PropTypes.string,\n    /**\n     * An accessor function that returns the updated label.\n     *\n     * For example, given labels with real numbers one can pass in the following accessor,\n     * (label) => `${label}%`, to display percentages.\n     */\n    format: PropTypes.func,\n    /**\n     * Formats to use for the labels in priority order. XAxisLabels will try to be smart about which format\n     * to use that keeps the labels distinct and provides the least amount of collisions when rendered. Formats\n     * can be either string(s) or function(s), utilizing d3-format.\n     *\n     * For example, given labels with real numbers one can pass in [\".0%\"] for a rounded percentage, like 12%.\n     */\n    formats: PropTypes.array,\n    /**\n     * Custom labels provided. Note that each object in the array has to be of shape.\n     * `{\n     *  value,\n     *  text,\n     *  height,\n     *  width\n     * }`\n     * value - value you'd like this label to be aligned with\n     * text - text you'd like displayed\n     * height - height of the given label\n     * width - width of the given label\n     */\n    labels: PropTypes.array,\n    /**\n     * Default label behavior places the text centered below the data point it delineates. This can allow\n     * overhang where the first and possibly last labels' text hangs over the edges of the x axis range.\n     * Setting this to `true` will force the first and last labels to align in such a way that their text does\n     * not exceed the x range. That is, the first label will be text-anchor: \"start\" instead of \"middle\", and\n     * the label marking the right edge of the chart will be anchored to the \"end\" instead of \"middle\".\n     *\n     * This affects spacing calculations.\n     */\n    noLabelOverhang: PropTypes.bool,\n    /**\n     * Round ticks to capture extent of given x domain from XYPlot.\n     */\n    nice: PropTypes.bool,\n    /**\n     * `mouseenter` event handler callback, called when user's mouse enters the label.\n     */\n    onMouseEnterLabel: PropTypes.func,\n    /**\n     * `mousemove` event handler callback, called when user's mouse moves within the label.\n     */\n    onMouseMoveLabel: PropTypes.func,\n    /**\n     * `mouseleave` event handler callback, called when user's mouse leaves the label.\n     */\n    onMouseLeaveLabel: PropTypes.func,\n    /**\n     * `mouseclick` event handler callback, called when user's mouse clicks the label.\n     */\n    onMouseClickLabel: PropTypes.func,\n    /**\n     * Adds horizontal offset (along the XAxis) to the labels\n     */\n    offset: PropTypes.number,\n  };\n\n  static defaultProps = {\n    offset: 0,\n    height: 250,\n    position: 'bottom',\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: '',\n    labelStyle: {\n      fontFamily: 'Helvetica, sans-serif',\n      fontSize: '14px',\n      lineHeight: 1,\n      textAnchor: 'middle',\n    },\n  };\n\n  static getTickDomain(props) {\n    if (!props.xScale) return;\n    const propsWithDefaults = defaults({}, props, XAxisLabels.defaultProps);\n    return {\n      xTickDomain: getTickDomain(propsWithDefaults.xScale, propsWithDefaults),\n    };\n  }\n\n  static getMargin(props) {\n    const propsWithDefaults = defaults({}, props, XAxisLabels.defaultProps);\n    const { xScale, position, placement, distance } = propsWithDefaults;\n    const labels =\n      propsWithDefaults.labels || XAxisLabels.getLabels(propsWithDefaults);\n    const zeroMargin = {\n      marginTop: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0,\n    };\n\n    if (\n      (position === 'bottom' && placement === 'above') ||\n      (position === 'top' && placement === 'below')\n    )\n      return zeroMargin;\n\n    const marginY = max(\n      labels.map(label => Math.ceil(distance + label.height)),\n    );\n    let textAnchor = 'middle';\n    if (propsWithDefaults.noLabelOverhang) {\n      textAnchor = 'start';\n    }\n    const [marginLeft, marginRight] = getLabelsXOverhang(\n      xScale,\n      labels,\n      textAnchor,\n    );\n\n    return defaults(\n      { [`margin${capitalize(position)}`]: marginY, marginLeft, marginRight },\n      zeroMargin,\n    );\n  }\n\n  static getLabels(props) {\n    const { tickCount, labelStyle, xScale } = defaults(\n      props,\n      {},\n      XAxisLabels.defaultProps,\n    );\n    const ticks = props.ticks || getScaleTicks(xScale, null, tickCount);\n    const style = {\n      labelStyle,\n      defaultStyle: XAxisLabels.defaultProps.labelStyle,\n    };\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const scaleType = inferScaleType(xScale);\n    const formatStrs =\n      Array.isArray(propsFormats) && propsFormats.length\n        ? propsFormats\n        : getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const { labels } = resolveXLabelsForValues(xScale, ticks, formats, style);\n\n    return labels;\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  render() {\n    const {\n      height,\n      xScale,\n      position,\n      distance,\n      labelStyle,\n      labelClassName,\n      spacingTop,\n      spacingBottom,\n      offset,\n    } = this.props;\n    const labels = this.props.labels || XAxisLabels.getLabels(this.props);\n    const placement =\n      this.props.placement || (position === 'top' ? 'above' : 'below');\n    const className = `rct-chart-value-label rct-chart-value-label-x ${labelClassName}`;\n    const transform =\n      position === 'bottom'\n        ? `translate(0, ${height + spacingBottom})`\n        : `translate(0, ${-spacingTop})`;\n    // todo: position: 'zero' to position along the zero line\n    // example include having both positive and negative areas and youd like labels just on zero line\n\n    return (\n      <g className=\"rct-chart-value-labels-x\" transform={transform}>\n        {labels.map((label, i) => {\n          const x = xScale(label.value) + offset;\n          const y = placement === 'above' ? -label.height - distance : distance;\n          const [onMouseEnter, onMouseMove, onMouseLeave, onClick] = [\n            'onMouseEnterLabel',\n            'onMouseMoveLabel',\n            'onMouseLeaveLabel',\n            'onMouseClickLabel',\n          ].map(eventName => {\n            // partially apply this label's data point as 2nd callback argument\n            const callback = get(this.props, eventName);\n            return isFunction(callback)\n              ? bindTrailingArgs(callback, label.value)\n              : null;\n          });\n          let textAnchor = 'middle';\n          if (this.props.noLabelOverhang) {\n            if (i === 0) textAnchor = 'start';\n            if (i === labels.length - 1 && xScale.range()[1] === x)\n              textAnchor = 'end';\n          }\n\n          const style = defaults(\n            { textAnchor },\n            getValue(labelStyle, { x, y, ...label }, i),\n            XAxisLabels.defaultProps.labelStyle,\n          );\n\n          return (\n            <g\n              key={`x-axis-label-${i}`}\n              aria-hidden=\"true\"\n              {...{ onMouseEnter, onMouseMove, onMouseLeave, onClick }}\n            >\n              {/* <XAxisLabelDebugRect {...{x, y, label}}/> */}\n              <MeasuredValueLabel\n                value={label.value}\n                {...{\n                  x,\n                  y,\n                  className,\n                  dy: '0.8em',\n                  style,\n                }}\n              >\n                {label.text}\n              </MeasuredValueLabel>\n            </g>\n          );\n        })}\n      </g>\n    );\n  }\n}\n\n/* eslint-disable */\nclass XAxisLabelDebugRect extends React.Component {\n  render() {\n    const { x, y, label } = this.props;\n    return (\n      <rect\n        {...{\n          x: x - label.width / 2,\n          y: y,\n          width: label.width,\n          height: label.height,\n          fill: 'orange',\n        }}\n      />\n    );\n  }\n}\n/* eslint-enable */\n\nexport default XAxisLabels;\n"],"file":"XAxisLabels.js"}